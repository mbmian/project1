#ECS 150 Project 1

##Introduction
This code represents a simple implementation of a shell. Commands are executed using a command line interface
Basic functionality of this code includes reading commands, then performing piping,redirection, error checking, or symbol/char 
identification to perform certain tasks requested by the user. This project had many challanges especially while implementing some of the functions mentioned below. At the end of the day it could not have been possiblw without teamwork, the resources provided by the professor and much research that we did along the way.

##Functions implemented

###replace_commands Function
The `replace_commands` function handles the substitution of environment variables with their respective values in command-line arguments. This function looks for the "$" symbol to identify the start of the argument and replaces the argument with the corresponding value if present in the environment variable. The purpose of this feature is to allow users to use environment variables in command line arguments to make their code more flexible and easier to use. 

###Pipeline
The `pipe` function was one of the phase that we found to be the hardest. We used code from Prof.Joel's slides and modified them to fully implement the functionality of this function. Various resources were used as a source of guidance to help us achieve each milestone in this phase. The whole idea involved understanding the basic concepts of forking without which this would have not been possible. Another problem that we faced was during the production of the code `replace_commands(arg->argument[cmd_index + 1]);`
and `(execvp(arg->argument[cmd_index + 1][0], arg->argument[cmd_index + 1]);` the first snippet is used to handle ouput of previous output to the input of the next command. While the next snippet uses the exec function to execute the next command in the pipeline by taking the filename and the parameters. Functions also face challenges such as managing input and output of commands in the pipeline and handling errors. In addition,the most difficult part that we found to be was how to handle muiltiple commands in the pipe and we had multiple ideas which involved creating multiple functions to handle each command but that turned out to be really ineffecient so we came up with the `execute_pipeline` function. Visually if we look at it `execute_pipeline` decides if there are multiple commands like pipes present if so itll call the pipe else itll handle the command itself.

###Execute_pipeline
The `execute_pipeline` function in this code is used to handle the pipeline function execution as needed. The purpose of this feature is to simplify the program and make it easier to understand and decide if a pipe is needed.When multiple commands are connected by a pipe symbol `(|)`, the `execute_pipeline` function is called to indicate that they should be executed as a pipeline. This function checks if routing is required, and if so, calls the pipeline function to execute the instruction down the pipeline. If you don't need the pipe, the function just executes a single command. The `execute_pipeline` function helps to simplify the main part of the code, making it easier to understand and modify if necessary. It is an important part of the shell code, as it helps to manage the execution of commands entered by the user. 

###Inspect_token
While developing our code we noticed the needed to parse the command line so the `cmdline` has all the arguments needed to be executed. So thats when we decided to develop a function whos function would only be to look at symbols of the command that would make it easier for the shell to determine what functions needed to be called based on their symbols. The hardest part was reseting the values such as `arg->argument[cmd_index][arg_index] = NULL; cmd_index++; arg_index = 0; redirect_stderr = 0;`. This part didnt come to us at once but was developed after many errors. Like we first figured out that the end of an array should be marked which was added and gradually the other parts such as how to ensrue that the stderr flag was set to 0 so the next command could be handled.

###Execting_commands
This function was easier than others as it involved checking a command and then calling the system to perform the specified task. Initially we did need to look up some online resources which are sited to see different function calls but other than that this part went really smooth for us.

###Error inspection
Though this is not a specific function but it is implemented throughout the program and I thought the need to add this here as it plays an important role in this project. Error handling was one of the key parts that we worked on till the end as there was many cases in which commands were either invalid or there was an error opening a directory which needed to be reported and it came as a challange of its own. The slides of Prof.Joel did help us understand some errors by looking at the code snippets but there was a need to look some up. In addition, once these errors were handled they were redirected to the error file, or displayed or even redirected to the stdoutput file. The hardest part we found and we found a solution for on piazza was the difference in fprintf and printf. We were getting the right error codes in our terminal but it was failing the test cases. After spending some time we happened to take a look on piazza as our last hope and we found our solution. A particular example of this was the second last test case `cd_pwd`. It was shwoing on our temrinal but but not on the CSIF. But luckily the solution was simple and didnt require much changing on our end 

###main
Our goal from day one was to keep the main as small and simple as possible so the main only calls functions and its job is done. This way it becames easier for us to not only debug but also understand how we could further modify specific parts of our code.

##Conclusion
This project was a serious challange for us as we had done nothing in the past like this. It was frusterating at times but now towards the end it seemed to be a valuable learning journey. Most importantly it helped implement core concepts from our lectures to a live example that I think we may remember for the years to come. Now moving towards the technical side of the project, we learned how to research information and relate it to our project. In addition, one thing that we may carry in the future with us is not being shy for asking for help. The reason is that in the industry there maybe many tasks that may not be solve-able by us alone and we need to ask help from either our co-workers or supervisors and this project helped us in breaking the ice and have a resourcefull conversation with others. 